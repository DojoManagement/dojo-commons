import json
from http import HTTPMethod
from typing import TYPE_CHECKING, Generic, TypeVar

from dojocommons.exception.business_exception import BusinessException
from dojocommons.log.logging import logger
from dojocommons.model.app_configuration import AppConfiguration
from dojocommons.model.base_entity import BaseEntity
from dojocommons.model.base_event import BaseEvent
from dojocommons.model.response import Response
from dojocommons.service.base_service import BaseService

if TYPE_CHECKING:
    from collections.abc import Callable

# Define um TypeVar para o tipo genérico da entidade
T = TypeVar("T", bound=BaseEntity)


# noinspection PyArgumentList
class BaseController(Generic[T]):
    """
    A base controller class for handling HTTP requests and delegating
    operations to the appropriate service and resource.

    This class is generic and works with any model that extends
    `pydantic.BaseModel`.

    :param cfg: The application configuration.
    :type cfg: AppConfiguration
    :param service_class: The service class responsible for business logic.
    :type service_class: Type[BaseService[T]]
    :param resource: The resource associated with the controller.
    :type resource: Type[BaseResource]
    :param model_class: The model class associated with the controller.
    :type model_class: Type[T]
    """

    def __init__(
        self,
        cfg: AppConfiguration,
        service_class: type[BaseService[T]],
        resource: str,
        model_class: type[T],
    ):
        """
        Initializes the BaseController with the given configuration, service,
        resource, and model class.
        """
        self._service = service_class(cfg)  # type: ignore[assignment]
        self._resource = resource
        self._model_class = model_class

        # Tipagem explícita para o _strategy
        self._strategy: dict[HTTPMethod, Callable[[BaseEvent], Response]] = {
            HTTPMethod.GET: self._get,
            HTTPMethod.POST: self._post,
            HTTPMethod.PUT: self._put,
            HTTPMethod.DELETE: self._delete,
        }

    def dispatch(self, event: BaseEvent) -> Response:
        """
        Dispatches the HTTP event to the appropriate handler based on the
        HTTP method.

        :param event: The HTTP event to be processed.
        :type event: BaseEvent
        :return: The response generated by the handler.
        :rtype: Response
        """
        logger.debug("Entrou em dispatch", event=event)

        method = self._strategy.get(event.http_method)
        if not method:
            return Response(status_code=405, body="Method Not Allowed")
        return method(event)

    def _get(self, event: BaseEvent) -> Response:
        """
        Handles HTTP GET requests.

        :param event: The HTTP event to be processed.
        :type event: BaseEvent
        :return: The response generated by the GET handler.
        :rtype: Response
        """
        logger.debug("Entrou em _get", event=event, resource=self._resource)

        try:
            if event.resource == self._resource:
                return self._list(event)
            if event.resource == f"{self._resource}/{{id}}":
                return self._get_by_id(event)

            logger.debug(
                "Recurso não corresponde ao esperado", resource=event.resource
            )
        except (ValueError, KeyError) as e:
            logger.exception("Erro ao processar a requisição GET", error=e)

        return Response(status_code=404, body="Resource not Found")

    def _list(self, event: BaseEvent) -> Response:
        """
        Retrieves a list of all entities.

        :param _event: The HTTP event to be processed.
        :type _event: BaseEvent
        :return: A response containing the list of entities.
        :rtype: Response
        """
        logger.debug("Entrou em _list", event=event)
        filters = event.query_parameters or {}
        entities = self._service.list_all(**filters)
        entity_list = {"items": [entity.model_dump() for entity in entities]}
        return Response(
            status_code=200,
            body=json.dumps(entity_list, ensure_ascii=False, default=str),
        )

    def _get_by_id(self, event: BaseEvent) -> Response:
        """
        Retrieves a single entity by its ID.

        :param event: The HTTP event containing the ID of the entity.
        :type event: BaseEvent
        :return: A response containing the entity or a 404 error if not found.
        :rtype: Response
        """
        if event.path_parameters is None:
            return Response(status_code=400, body="Bad Request: Missing ID")

        if (entity_id := event.path_parameters.get("id")) is None:
            return Response(status_code=400, body="Bad Request: Missing ID")

        entity = self._service.get_by_id(entity_id)
        if not entity:
            return Response(status_code=404, body="Entity not found")
        body = f'{{"item": {entity.model_dump_json(exclude_none=True)}}}'
        return Response(status_code=200, body=body)

    def _post(self, event: BaseEvent) -> Response:
        """
        Creates a new entity.

        :param event: The HTTP event containing the entity data in the body.
        :type event: BaseEvent
        :return: A response containing the created entity.
        :rtype: Response
        """
        try:
            logger.debug("Entrou em _post", event=event)

            if event.body is None:
                return Response(
                    status_code=400, body="Bad Request: Missing body"
                )

            entity = self._model_class.model_validate_json(event.body)
            entity = self._service.create(entity)
            body = f'{{"item": {entity.model_dump_json(exclude_none=True)}}}'
            self._service.persist()
            return Response(status_code=201, body=body)
        except BusinessException as e:
            return Response(
                status_code=e.status_code, body={"error": e.message}
            )
        except (ValueError, TypeError, json.JSONDecodeError) as e:
            logger.exception("Erro ao criar entidade", error=e)
            return Response(
                status_code=500,
                body={"error": "Erro interno ao criar entidade"},
            )

    def _put(self, event: BaseEvent) -> Response:
        """
        Updates an existing entity.

        :param event: The HTTP event containing the entity ID and updated data.
        :type event: BaseEvent
        :return: A response containing the updated entity or a 404 error if
        not found.
        :rtype: Response
        """
        if event.path_parameters is None:
            return Response(status_code=400, body="Bad Request: Missing ID")

        if (entity_id := event.path_parameters.get("id")) is None:
            return Response(status_code=400, body="Bad Request: Missing ID")

        existing_entity = self._service.get_by_id(entity_id)

        if not existing_entity:
            return Response(status_code=404, body="Entity not found")

        if event.body is None:
            return Response(status_code=400, body="Bad Request: Missing body")

        updates = self._model_class.model_validate_json(event.body)
        updated_entity = self._service.update(updates)

        if updated_entity is None:
            return Response(status_code=500, body="Erro ao atualizar entidade")

        body = (
            f'{{"item": {updated_entity.model_dump_json(exclude_none=True)}}}'
        )
        self._service.persist()
        return Response(status_code=200, body=body)

    def _delete(self, event: BaseEvent) -> Response:
        """
        Deletes an entity by its ID.

        :param event: The HTTP event containing the entity ID.
        :type event: BaseEvent
        :return: A response indicating the deletion status.
        :rtype: Response
        """
        if event.path_parameters is None:
            return Response(status_code=400, body="Bad Request: Missing ID")

        if (entity_id := event.path_parameters.get("id")) is None:
            return Response(status_code=400, body="Bad Request: Missing ID")

        self._service.delete(entity_id)
        self._service.persist()

        return Response(status_code=204, body=None)
